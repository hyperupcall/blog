<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.85.0"><title>Semantic Hotkeys - Edwin Kofler</title><meta property="og:title" content="Semantic Hotkeys - Edwin Kofler"><link href=https://hyperupcall.github.io/blog/index.xml rel=alternate type=application/rss+xml title="Edwin Kofler"><link rel=stylesheet href=https://hyperupcall.github.io/blog/css/open-color.css media=all><link rel=stylesheet href=https://hyperupcall.github.io/blog/css/main.css media=all><link rel=stylesheet href=https://hyperupcall.github.io/blog/css/fonts.css></head><body><div class=wrapper><header class=header><nav class=nav><a href=https://hyperupcall.github.io/blog/ class=nav-logo><img src=https://hyperupcall.github.io/blog/images/logo.jpg width=50 height=50 alt=Logo></a><ul class=nav-links><li><a href=../../categories>Categories</a></li><li><a href=../../tags>Tags</a></li><li><a href=../../about/>About</a></li></ul></nav></header><main class=content role=main><article class=article><h1 class=article-title>Semantic Hotkeys</h1><div class=article-content><p>Hotkeys are present in nearly all software. However, in my view, both software users and application developers do not realize the full potential of hotkeys.</p><p>I believe the full productivity of hotkeys can be unleashed through the concept of <em>semantic hoteys</em>. First I&rsquo;ll introduce some current problems with hotkeys, then I&rsquo;ll explain how <em>semantic hotkeys</em> can provide a solution.</p><h2 id=current-woes>Current Woes</h2><p>The crux of my claims boils down to consistency. In one perspective, there are three costs of hotkeys:</p><ol><li>The cost of learning</li><li>The cost of context-switching</li><li>The cost of hotkey clobbering</li></ol><p>The first cost is somewhat-inevitable, especially for large enterprise softwares like <a href=https://www.blender.org>Blender</a> or <a href=https://www.sidefx.com>Houdini</a>. Sometimes, this cost is rarely a consideration because it is easily amortized by ample use of the hotkeys themselves. But, with less frequently-used applications, it is often not worth learning the hotkeys. The cost of learning hotkeys of a particular application is typically not proportional to the total time using that application.</p><p>The second cost deals with context switching among multiple applications (that have different sets of hotkeys). A high familiarity with each applications' hotkeys can mitigate this penalty somewhat, but it will always exist. As applications with incongruent hotkeys increase, the cost of context switching will only remain high.</p><p>The third cost involves clobbering. This can occur in applications that provide an extension or plugin environment, such as VSCode or NeoVim. Hotkeys of extensions are often defined arbitrarily, usually just set for the sake of being set. This creates high potential for hotkey clobbering; such conflicts have to be resolved manually. Inconsistent conventions make learning new hotkeys, especially those defined within plugin-based environments, difficult.</p><h2 id=solution>Solution</h2><p>An ideal solution involves constructing a set of shared keyboard shortcuts across applications. But, the meaning of those shortcuts mustn&rsquo;t be domain specific; they must translate intuitively.</p><p>Introducing, semantic hotkeys:</p><ul><li><em>Semantic Hotkey</em>: A hotkey in which the keypresses that define it have semantics rooted in physicalities or commonalities<ul><li>Example: <code>WASD</code> and <code>HJKL</code> have semantics of orientation or directed movement based on the arrangement of said keys</li><li>Example: <code>Ctrl+Tab</code> and <code>Ctrl+Shift+Tab</code> to move view right and left, respectively.<ul><li><code>Tab</code> semantically equivalent to cycle (cycle through form fields, tabs, application windows, etc.)</li><li>But still sightly less semantic compared to the previous example because the modifier <code>Shift</code> does not consistently mean &ldquo;backwards&rdquo; or &ldquo;opposite&rdquo;.</li></ul></li><li>Example: <code>Ctrl+[</code>, <code>Ctrl+(</code>, <code>Ctrl+{</code> to move to end of discrete element (ex. symbol, closed brace, etc).<ul><li>The level of &ldquo;curviness&rdquo; of each brace may be meaningful in any particular context</li></ul></li></ul></li></ul><p>The &ldquo;physicalities&rdquo; and &ldquo;commonalities&rdquo; part of semantic hotkeys ensure that the semantic are either shared or intuitive enough. The penalty of context switching would decrease.</p><p>In contrast,</p><ul><li><em>Syntactic Hotkey</em>: A hotkey in which the keypresses that define it have semantics rooted in (partial) superficialities<ul><li>Example: <code>Ctrl+P</code> means go to <strong>p</strong>revious history item in many shells (rooted in English grammar)</li><li>Example: <code>Ctrl+F</code> means <strong>f</strong>ind item in current document (rooted in English grammar)</li><li>Example: <code>Delete</code> and <code>PageUp</code><ul><li>These are dedicated keys, so their semantic meaning is inherently superficial</li><li>Tangentially, not all keyboards have these buttons so their utility is questionable</li></ul></li></ul></li></ul><p>By defining and using semantic hotkeys more than syntactic hotkeys, the cost of learning new shortcuts is lower.</p><p>Furthermore, semantic hotkeys are more resilient to any changes of the Human Computer Interface itself</p><ul><li>Example: Changing the keyboard layout from QWERTY to DVORAK or changing the keyboard language from English to Deutsch will not significantly change the meaning or position of the shortcut.</li><li>Example: Replacing the keybord with, say, gloves that have acceleration, orientation, etc. tracking could still yield similar &ldquo;shortcuts&rdquo; in whatever form they exist</li></ul><p>With semantic shortcuts, it may be possible for the Operating System to handle shortcut transformations, rather than the applications themselves.
(If Cut, Copy, and Paste were semantic, then the Colemak keyboard would not need to exist)</p><ul><li>Supports custom mapping from hotkey to action</li><li>Supports chording hotkeys</li></ul><h2 id=implementation>Implementation</h2><p>For each application, from a common JSON file (with keys being semantic keys and values being the shortcuts themselves), configuration for each native application is created.
A reasonable implementation assumes that each applicable application supports:</p><p>Of course, there are many actions that don&rsquo;t correspond to a shortcut, or a shortcut has a nuanced meaning. But, those ca be accounted for via escape hatches</p><ul><li>Custom mapping from hotkey to action</li><li>Chorded hotkeys</li></ul><p>The keys <code>h</code>, <code>j</code>, <code>k</code>, <code>l</code> are a great starting point - they correspond to directions. More specifically, they move a cursor, selection, or item directionally within a particular context.</p><ul><li>Vim: Cursor within a buffer</li><li>Window Manager: Window within a virtual desktop</li><li>Terminal Multiplexer: Pane within a terminal</li></ul><p>We can generalize:</p><ul><li>Selection navigate within context</li><li>Selection move within context</li><li>Selection move to new context</li><li>Context navigate relatively</li><li>Context move relatively</li></ul><p>Important to note that contexts can simultaneously be sections. Semantics can be more fine-tuned to fit into concrete categories. In the context of <em>DE Workspaces</em>, <em>Application Windows</em>, <em>Terminal Panes</em>, a unified language</p><h3 id=challenges>Challenges</h3><p>Challenges include nested applications</p><p>For example, of an arbitrary terminal app, there are multiple possible nestings (which can affect shortcut semantics):</p><ul><li>Terminal App</li><li>Terminal App in tmux</li><li>Terminal App in tmux in Kitty</li><li>Terminal App in tmux in Kitty in VM / Container</li></ul><h2 id=similar-ideas>Similar ideas</h2><p>Benefits users because shortcuts:</p><ul><li>Are an invariant with respect to keyboard layout and language</li><li>Help interface designers improve UX by making UI paths more explicit</li><li>Employ two different sides of the keyboard for faster switching (DVORAK-esque)
Become only more useful due to the gridification and flexification of layouts - convergence creates more consistency within interfaces</li></ul><p>See <a href=https://github.com/semantic-hotkeys>github.com/semantic-hotkeys</a> to see this in action</p></div><ul class=article-taxonomy><hr><li><i class="fa fa-category"></i><a href=../../categories/hotkeys>hotkeys</a></li><li><i class="fa fa-tags"></i><a href=../../tags/user-interface>user-interface</a></li></article></main><footer class=footer><ul class=footer-links><li><a href=https://hyperupcall.github.io/blog/index.xml type=application/rss+xml target=_blank><i class="fa fa-rss"></i> RSS feed</a></li><li><a href=../../>Home</a></li><li><a href=https://hyperupcall.github.io/blog/site-notice>Site notice</a></li></ul></footer></div></body><script async src="https://www.googletagmanager.com/gtag/js?id=UA-88833922-3"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","UA-88833922-3")</script></html>