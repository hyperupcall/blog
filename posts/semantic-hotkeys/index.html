<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.85.0"><title>Semantic Hotkeys - Edwin Kofler</title><meta property="og:title" content="Semantic Hotkeys - Edwin Kofler"><link href=https://hyperupcall.github.io/blog/index.xml rel=alternate type=application/rss+xml title="Edwin Kofler"><link rel=stylesheet href=https://hyperupcall.github.io/blog/css/open-color.css media=all><link rel=stylesheet href=https://hyperupcall.github.io/blog/css/main.css media=all><link rel=stylesheet href=https://hyperupcall.github.io/blog/css/fonts.css></head><body><div class=wrapper><header class=header><nav class=nav><a href=https://hyperupcall.github.io/blog/ class=nav-logo><img src=https://hyperupcall.github.io/blog/images/logo.jpg width=50 height=50 alt=Logo></a><ul class=nav-links><li><a href=../../categories>Categories</a></li><li><a href=../../tags>Tags</a></li><li><a href=../../about/>About</a></li></ul></nav></header><main class=content role=main><article class=article><h1 class=article-title>Semantic Hotkeys</h1><div class=article-content><p>Hotkeys are present in nearly all software. However, in my view, both software users and application developers do not realize the full potential of hotkeys</p><p>I believe the full productivity of hotkeys can be unleashed through the concept of <em>semantic hoteys</em>. First I&rsquo;ll introduce current problems with hotkeys, then some hotkey definitions, and lastly my proposed solutions.</p><p>Note: Persuasion through evidence-hardened claims is not my intention; I only wish to express my thoughts. If you agree with me, great; if not, that&rsquo;s fine too.</p><h2 id=current-woes>Current Woes</h2><p>The crux of my claims boils down to consistency. In one perspective, there are three costs of hotkeys:</p><ol><li>The cost of learning</li><li>The cost of context-switching</li><li>The cost of hotkey clobbering / conflicts</li></ol><p>The first cost is somewhat-inevitable, especially for large enterprise softwares like <a href=https://www.blender.org>Blender</a> or <a href=https://www.sidefx.com>Houdini</a>. Sometimes, this cost is rarely a consideration because it is easily amortized by ample use of the hotkeys themselves. But, with less frequently-used applications, it is often not worth learning the hotkeys. The cost of learning hotkeys of a particular application is not proportional the usage frequency of that application.</p><p>The second cost deals with context switching among multiple applications (that have different sets of hotkeys). A high familiarity with each applications' hotkeys can mitigate this penalty somewhat, but it will always exist. As applications with incongruent hotkeys increase, the cost of context switching will only remain high.</p><p>The third cost involves clobbering. This can occur in applications that provide an extension or plugin environment, such as VSCode or NeoVim. Hotkeys of extensions are often defined arbitrarily, usually just set for the sake of being set. This creates high potential for hotkey clobbering; such conflicts have to be resolved manually. Inconsistent conventions make learning new hotkeys, especially those defined within plugin-based environments, difficult.</p><h2 id=definitions>Definitions</h2><ul><li><em>Semantic Hotkey</em>: A hotkey in which the keypresses that define it have semantics rooted in physicalities or positionalities<ul><li>Example: <code>WASD</code> and <code>HJKL</code> have semantics of orientation or directed movement based on the arrangement of said keys</li><li>Example: <code>Ctrl+Tab</code> and <code>Ctrl+Shift+Tab</code> to move view right and left, respectively.<ul><li><code>Tab</code> semantically equivalent to cycle (cycle through form fields, tabs, application windows, etc.)</li><li>But still sightly less semantic compared to the previous example because the modifier <code>Shift</code> does not consistently mean &ldquo;backwards&rdquo; or &ldquo;opposite&rdquo;.</li></ul></li><li>Example: <code>Ctrl+[</code>, <code>Ctrl+(</code>, <code>Ctrl+{</code> to move to end of discrete element (ex. symbol, closed brace, etc).<ul><li>The level of &ldquo;curviness&rdquo; of each brace may be meaintful to a particular application</li></ul></li></ul></li></ul><p>In contrast,</p><ul><li><em>Syntactic Hotkey</em>: A hotkey in which the keypresses that define it have semantics rooted in (partial) superficialities<ul><li>Example: <code>Ctrl+P</code> means go to <strong>p</strong>revious history item in many shells (rooted in English grammar)</li><li>Example: <code>Ctrl+F</code> means <strong>f</strong>ind item in current document (rooted in English grammar)</li><li>Example: <code>Delete</code> and <code>PageUp</code> (both are dedicated keys)</li></ul></li></ul><p>Some other notes:</p><ul><li>Semantic hotkeys are more resilient to any changes of the Human Computer Interface itself<ul><li>Example: Changing the keyboard layout from QWERTY to DVORAK will not change semantic meaning - but it is the responsibility of either the OS or application to respect that</li><li>Example: Replacing the keybord with, say, gloves that have acceleration, orientation, etc. tracking will still yield similar &ldquo;shortcuts&rdquo; in whatever form they exist</li></ul></li><li>Syntactic Hotkeys are responsible for much of the the cost of learning new shortcuts</li><li>Hotkeys like <code>PageUp</code> may sound good, but<ul><li>Analogous iPhone to BlackBerry, dedicated keys are inflexible</li><li>Is not accessible on 60% keyboards, or is too difficult to press</li></ul></li></ul><h2 id=proposed-solution>Proposed Solution</h2><p>My solution assumes that each applicable application:</p><ul><li>Supports custom mapping from hotkey to action</li><li>Supports chording hotkeys</li></ul><p>For each application, from a common JSON file (with keys being semantic keys and values being the shortcuts themselves), configuration for each native application is created.</p><p>Of course, there are many actions that don&rsquo;t correspond to a shortcut, or a shortcut has a nuanced meaning. But, those ca be accounted for via escape hatches</p><h2 id=benefits>Benefits</h2><p>Benefits users because shortcuts:</p><ul><li>Are an invariant with respect to keyboard layout and language</li><li>Help interface designers improve UX by making UI paths more explicit
Become only more useful due to the gridification and flexification of layouts - convergence creates more consistency within interfaces</li></ul><h2 id=challanges>Challanges</h2><p>Nested contexts are a challange. For example, in the case of Kitty wrapping tmux wrapping Vim as opposed to just Vim itself.</p><p>See <a href=https://github.com/semantic-hotkeys>github.com/semantic-hotkeys</a> to see this in action</p></div><ul class=article-taxonomy><hr><li><i class="fa fa-category"></i><a href=../../categories/hotkeys>hotkeys</a></li><li><i class="fa fa-tags"></i><a href=../../tags/user-interface>user-interface</a></li></article></main><footer class=footer><ul class=footer-links><li><a href=https://hyperupcall.github.io/blog/index.xml type=application/rss+xml target=_blank><i class="fa fa-rss"></i> RSS feed</a></li><li><a href=../../>Home</a></li><li><a href=https://hyperupcall.github.io/blog/site-notice>Site notice</a></li></ul></footer></div></body><script async src="https://www.googletagmanager.com/gtag/js?id=UA-88833922-3"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","UA-88833922-3")</script></html>